<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Isaac Li">
<meta property="og:url" content="http://Isaac-Li.github.io/page/3/index.html">
<meta property="og:site_name" content="Isaac Li">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Isaac Li">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://Isaac-Li.github.io/page/3/"/>





  <title>Isaac Li</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Isaac Li</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">码农 + 测试</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Isaac-Li.github.io/2018/09/06/损失函数汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Isaac Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Isaac Li">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/损失函数汇总/" itemprop="url">损失函数汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T14:27:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Machine Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1. 0-1损失函数和绝对值损失函数 </strong></p>
<p>  0-1损失是指，预测值和目标值不相等为1，否则为0：</p>
<p><img src="/2018/09/06/损失函数汇总/images/pasted-46.png" alt="upload successful"></p>
<p>  感知机就是用的这种损失函数。但是由于相等这个条件太过严格，因此我们可以放宽条件，即满足 |Y−f(X)|&lt;T 时认为相等。 </p>
<p><img src="/2018/09/06/损失函数汇总/images/pasted-47.png" alt="upload successful"></p>
<p>  绝对值损失函数为：<br>  L(Y,f(X)=|Y−f(X)|</p>
<p><strong>2. Logistic regression </strong></p>
<p><img src="/2018/09/06/损失函数汇总/images/pasted-44.png" alt="upload successful"></p>
<p><img src="/2018/09/06/损失函数汇总/images/pasted-45.png" alt="upload successful"><br>    logistic regression可以将实数域的输入映射为0到1的概率输出</p>
<p><strong>3. 平方损失函数</strong></p>
<p>  最小二乘法是线性回归的一种方法，它将回归的问题转化为了凸优化的问题。最小二乘法的基本原则是：最优拟合曲线应该使得所有点到回归直线的距离和最小。通常用欧几里得距离进行距离的度量。平方损失的损失函数为： </p>
<p><img src="/2018/09/06/损失函数汇总/images/pasted-48.png" alt="upload successful"></p>
<p><strong>4.  指数损失函数 </strong></p>
<p>  指数损失是0-1损失函数的一种代理函数。运用指数损失的典型分类器是AdaBoost算法。<br>  指数损失函数的标准形式： </p>
<p><img src="/2018/09/06/损失函数汇总/images/pasted-49.png" alt="upload successful"></p>
<p><strong>5. Hinge损失函数 </strong></p>
<p>  Hinge损失函数和SVM是息息相关的。在线性支持向量机中，最优化问题可以等价于 </p>
<p><img src="/2018/09/06/损失函数汇总/images/pasted-50.png" alt="upload successful"></p>
<p>  这个式子和如下的式子非常像： </p>
<p><img src="/2018/09/06/损失函数汇总/images/pasted-51.png" alt="upload successful"></p>
<p>  其中l(wxi+byi)就是hinge损失函数，后面相当于L2正则项。<br>  Hinge函数的标准形式： </p>
<p><img src="/2018/09/06/损失函数汇总/images/pasted-52.png" alt="upload successful"></p>
<p>  y是预测值，在-1到+1之间，t为目标值（-1或+1）。其含义为，y的值在-1和+1之间就可以了，并不鼓励|y|&gt;1，即并不鼓励分类器过度自信，让某个正确分类的样本的距离分割线超过1并不会有任何奖励，从而使分类器可以更专注于整体的分类误差。  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Isaac-Li.github.io/2018/09/05/Hadoop-源码-org-apache-hadoop-hdfs-protocolPB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Isaac Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Isaac Li">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/Hadoop-源码-org-apache-hadoop-hdfs-protocolPB/" itemprop="url">Hadoop 源码-org.apache.hadoop.hdfs.protocolPB</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T15:07:00+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index">
                    <span itemprop="name">Big Data</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>PB 为 Protocol Buffer 的缩写</p>
<ol>
<li><p>AliasMapProtocolPB 接口 与 AliasMapProtocolServerSideTranslatorPB 类</p>
<p> <img src="/2018/09/05/Hadoop-源码-org-apache-hadoop-hdfs-protocolPB/images/pasted-38.png" alt="upload successful"><br>  AliasMapProtocolPB 接口注释：Protocol between the Namenode and the Datanode to read the AliasMap. used for Provided storage.</p>
<p> AliasMapProtocolServerSideTranslatorPB类实现自 AliasMapProtocolPB 接口。</p>
<p> AliasMapProtocolServerSideTranslatorPB类注释：AliasMapProtocolServerSideTranslatorPB is responsible for translating RPC calls and forwarding them to the internal InMemoryAliasMap.</p>
</li>
<li><p>ClientDatanodeProtocolServerSideTranslatorPB 类 ClientDatanodeProtocolPB 接口</p>
<p> ClientDatanodeProtocolServerSideTranslatorPB 类实现自 ClientDatanodeProtocolPB 接口</p>
<p> <img src="/2018/09/05/Hadoop-源码-org-apache-hadoop-hdfs-protocolPB/images/pasted-41.png" alt="upload successful"></p>
</li>
<li><p>ClientNamenodeProtocolServerSideTranslatorPB 类 ClientNamenodeProtocolPB 接口 接口与实现类</p>
</li>
<li><p>DatanodeLifelineProtocolServerSideTranslatorPB 类DatanodeLifelineProtocolPB 接口 接口与实现类</p>
</li>
<li><p>DatanodeLifelineProtocolClientsideTranslatorPB 类 </p>
<p> <img src="/2018/09/05/Hadoop-源码-org-apache-hadoop-hdfs-protocolPB/images/pasted-42.png" alt="upload successful"></p>
</li>
<li><p>DatanodeProtocolPB 接口 DatanodeProtocolServerSideTranslatorPB 类 接口与实现类</p>
</li>
<li><p>InterDataNodeProtocolPB 接口 InterDatanodeProtocolServerSideTranslatorPB 类 接口与实现类</p>
</li>
<li><p>JournalProtocolPB 接口 JournalProtocolServerSideTranslatorPB 类 接口与实现类</p>
</li>
<li><p>NamenodeProtocolPB 接口 NamenodeProtocolServerSideTranslatorPB 类 接口与实现类</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Isaac-Li.github.io/2018/09/04/Hadoop-源码-org-apache-hadoop-hdfs-protocol-datatransfer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Isaac Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Isaac Li">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/Hadoop-源码-org-apache-hadoop-hdfs-protocol-datatransfer/" itemprop="url">Hadoop 源码-org.apache.hadoop.hdfs.protocol.datatransfer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T15:48:00+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index">
                    <span itemprop="name">Big Data</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>BlackListBasedTrustedChannelResolver</p>
<p> BlackListBasedTrustedChannelResolver 类继承自 TrustedChannelResolver 类</p>
<p> 类注释：Class used to indicate whether a channel is trusted or not. The default implementation is to return false indicating that the channel is not trusted.</p>
<p> The class can be overridden to provide custom logic to determine whether a channel is trusted or not. The custom class can be specified via configuration.</p>
</li>
<li><p>Receiver</p>
<p> Receiver 实现 DataTransferProtocol接口，该接口用于——Transfer data to/from datanode using a streaming protocol (between clients and datanodes).</p>
</li>
<li><p>WhiteListBasedTrustedChannelResolver</p>
<p> WhiteListBasedTrustedChannelResolver 继承自 TrustedChannelResolver 类</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Isaac-Li.github.io/2018/09/04/Hadoop-源码-org-apache-hadoop-hdfs-protocol/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Isaac Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Isaac Li">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/Hadoop-源码-org-apache-hadoop-hdfs-protocol/" itemprop="url">Hadoop 源码-org.apache.hadoop.hdfs.protocol</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-04T13:27:00+08:00">
                2018-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index">
                    <span itemprop="name">Big Data</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
<ol>
<li><p>BlockListAsLongs 类</p>
<p> BlockListAsLonngs 类继承自 java.lang.Iterable 接口    </p>
</li>
<li><p>CacheDirective</p>
<p> CacheDirective 类继承自 org.apache.hadoop.util.InstrusiveCollection 类</p>
<p> 类注释：Namenode class that tracks state related to a cached path.</p>
</li>
<li><p>FSLimitException</p>
<p> FSLimitException类继承自 org.apache.hadoop.hdfs.protocol.QuotaExceededException</p>
<p> 类注释：Abstract class for deriving exceptions related to filesystem constraints.</p>
</li>
<li><p>LayoutFlags</p>
<p> 类注释：LayoutFlags represent features which the FSImage and edit logs can either support or not, independently of layout version.</p>
</li>
<li><p>LayoutVersion</p>
<p> 类注释：This class tracks changes in the layout version of HDFS. </p>
<p> Layout version is changed for following reasons:</p>
<p> a. The layout of how namenode or datanode stores information on disk changes.</p>
<p> b. A new operation code is added to the editlog.</p>
<p> c. Modification such as format of a record, content of a record in editlog or fsimage.</p>
</li>
<li><p>RecoveryInProgressException</p>
<p> RecoveryInProgressException 类继承自 IOException</p>
<p> 类注释：Exception indicating that a replica is already being recovery.</p>
</li>
<li><p>RollingUpgradeException</p>
<p> RollingUpgradeException 类继承自 IOException</p>
<p> 类注释：Exception related to rolling upgrade.</p>
</li>
<li><p>SnapshotException</p>
<p> SnapshotException 类继承自 IOException</p>
<p> 类注释：Snapshot related exception</p>
</li>
<li><p>SnapshotInfo</p>
<p> 类注释：SnapshotInfo maintains information for a snapshot.</p>
</li>
<li><p>UnregisteredNodeException</p>
<p>UnregisteredNodeException 类继承自 IOException</p>
<p>类注释：This exception is thrown when a node that has not previously registered is trying to access the name node.</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Isaac-Li.github.io/2018/09/03/Hadoop-源码-org-apache-hadoop-hdfs-net/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Isaac Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Isaac Li">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/Hadoop-源码-org-apache-hadoop-hdfs-net/" itemprop="url">Hadoop 源码-org.apache.hadoop.hdfs.net</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T16:16:00+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index">
                    <span itemprop="name">Big Data</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>org.apahce.hadoop.hdfs.net 包</p>
<ol>
<li><p>DFSNetWorkTopology 类</p>
<p> DFSNetWorkTopology 继承自 NetWorkTopology类</p>
<p>类注释：The HDFS specific network topology class. The main purpose of doing this subclassing is to add storage-type-aware chooseRandom method. All the remaining parts should be the same.</p>
</li>
<li><p>DFSTopologyNodeImpl 类</p>
<p> DFSTopologyNodeImpl 继承自 InnerNodeImpl 类<br> <img src="/2018/09/03/Hadoop-源码-org-apache-hadoop-hdfs-net/images/pasted-35.png" alt="upload successful"><br>类注释：The HDFS specific representation of a network topology inner node. The difference is thsi class includes the information about the storage type info of this subtree. This info will be used when selecting subtrees in block placement. </p>
</li>
<li><p>DomainPeerServer 类</p>
<p> DomainPeerServer 类继承自 PeerServer 接口<br><img src="/2018/09/03/Hadoop-源码-org-apache-hadoop-hdfs-net/images/pasted-36.png" alt="upload successful"></p>
</li>
<li><p>PeerServer 接口</p>
</li>
<li><p>TcpPeerServer 类</p>
<p> TcpPeerServer 类继承自 PeerServer 接口</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Isaac-Li.github.io/2018/08/31/Hadoop-源码-org-apache-hadoop-hdfs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Isaac Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Isaac Li">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/31/Hadoop-源码-org-apache-hadoop-hdfs/" itemprop="url">Hadoop 源码-org.apache.hadoop.hdfs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-31T16:23:00+08:00">
                2018-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Big-Data/" itemprop="url" rel="index">
                    <span itemprop="name">Big Data</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>org.apache.hadoop.hdfs 包内共包含10个类</p>
<p>1.DeprecatedUTF8 类</p>
<p><img src="/2018/08/31/Hadoop-源码-org-apache-hadoop-hdfs/images/pasted-30.png" alt="upload successful"></p>
<p>DeprecatedUTF8 类继承自 org.apache.hadoop.io.UTF8 类</p>
<p>源码中注释信息： A simple wrapper around org.apache.hadoop.io.UTF8. This class should be used only when it is absolutely necessary to use org.apache.hadoop.io.UTF8. The only difference is that using this class does not require @SuppressWarning annotation to avoid javac warning. Instead the deprecation is implied in the class name.</p>
<p>This should be treated as package private class to HDFS.</p>
<p>2.DFSConfigKeys 类</p>
<p>类继承关系如下图<br><img src="/2018/08/31/Hadoop-源码-org-apache-hadoop-hdfs/images/pasted-31.png" alt="upload successful"></p>
<p>源码中的注释信息：This class contains constants for configuration keys and default values used in hdfs.</p>
<p>该类只包含了hdfs中使用所有配置信息，并没有包含任何方法。这是值得学习的地方。另外该类继承的父类也是包含配置信息的类，在这种只有配置信息的地方使用继承也是值得学习的地方。</p>
<p>3.DFSUtil 类</p>
<p>类继承关系图如下图</p>
<p><img src="/2018/08/31/Hadoop-源码-org-apache-hadoop-hdfs/images/pasted-32.png" alt="upload successful"><br>该类方法众多，不过主要的方法集中在处理URI地址上了。</p>
<p>ConfigureNNAddress 是一个内部静态类，用于存储一个 NameNode 的配置信息。</p>
<p>ServiceComparator 是一个内部静态类，继承自 Comparator，该类主要用于对 DataNodeInfo[] 进行排序，decommissioned 节点将被移到列表的末尾。 ENTERING_MAINTENANCE 节点将被移到 live 节点后。</p>
<p>ServiceAndStaleComparator 是一个内部静态类，继承自 ServiceComparator. Stale 节点将被移到正常节点后</p>
<p>4.HAUtil 类</p>
<p>该类用于对处于HA（高可用 High Availability，HA) 方案模式下的NameNode的操作，包括获取 NameNodeID、获取配置信息、获取主 NameNode地址等<br><img src="/2018/08/31/Hadoop-源码-org-apache-hadoop-hdfs/images/pasted-33.png" alt="upload successful"><br>从上图中，我们可以看出 NameNode 的高可用架构主要分为下面几个部分：<br>Active NameNode 和 Standby NameNode：两台 NameNode 形成互备，一台处于 Active 状态，为主 NameNode，另外一台处于 Standby 状态，为备 NameNode，只有主 NameNode 才能对外提供读写服务。<br>主备切换控制器 ZKFailoverController：ZKFailoverController 作为独立的进程运行，对 NameNode 的主备切换进行总体控制。ZKFailoverController 能及时检测到 NameNode 的健康状况，在主 NameNode 故障时借助 Zookeeper 实现自动的主备选举和切换，当然 NameNode 目前也支持不依赖于 Zookeeper 的手动主备切换。<br>Zookeeper 集群：为主备切换控制器提供主备选举支持。<br>共享存储系统：共享存储系统是实现 NameNode 的高可用最为关键的部分，共享存储系统保存了 NameNode 在运行过程中所产生的 HDFS 的元数据。主 NameNode 和<br>NameNode 通过共享存储系统实现元数据同步。在进行主备切换的时候，新的主 NameNode 在确认元数据完全同步之后才能继续对外提供服务。<br>DataNode 节点：除了通过共享存储系统共享 HDFS 的元数据信息之外，主 NameNode 和备 NameNode 还需要共享 HDFS 的数据块和 DataNode 之间的映射关系。DataNode 会同时向主 NameNode 和备 NameNode 上报数据块的位置信息。</p>
<p>5.HdfsConfiguration 类</p>
<p>HdfsConfiguration 类继承自 Configuration 类, 主要方法 addDeprecatedKeys</p>
<p>6.HdfsDtFetcher 类</p>
<p>HdfsDtFetcher 类继承自 DtFetecher 接口</p>
<p>类注释：DtFetcher is an interface which permits the abstraction and separation of delegation token fetch implementation across different packages and compilation units. Resolution of fetcher impl will be done at runtime.</p>
<p>主要方法 addDelegationTokens</p>
<p>7.HDFSPolicyProvider 类</p>
<p>HDFSPolicyPorvider 类继承自 PolicyProvider 类</p>
<p>PolicyProvider 类用于提供Hadoop系统的安全定义。</p>
<p>主要方法 getServices</p>
<p>8.NameNodeProxies 类</p>
<p>类注释：Create Proxy objects to communicate with a remote NN. All remote access to an NN should be funneled through this class. Most of the time you’ll want to use NamenodeProxies.createProxy， which will create wither an HA- or non-HA-enabled client proxy as appropriate.</p>
<p>9.SWebHdfsDtFetcher 类</p>
<p>SWebHdfsDtFetcher 类继承自 HdfsFetcher 类</p>
<p>类注释：DtFetcher for SWebHdfsFileSystem using the base class HdfsDtFetcher impl.</p>
<p>主要方法 getServiceName</p>
<p>10.WebHdfsDtFetcher 类</p>
<p>WebHdfsDtFetcher 类继承自 HdfsFetcher 类</p>
<p>类注释：DtFetcher for WebHdfsFileSystem using the base class HdfsDtFetcher impl.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Isaac-Li.github.io/2018/08/24/神经网络-VGG/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Isaac Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Isaac Li">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/24/神经网络-VGG/" itemprop="url">神经网络-VGG</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-24T09:20:00+08:00">
                2018-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Deep Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>VGG 网络结构图</p>
<p><img src="/2018/08/24/神经网络-VGG/images/pasted-20.png" alt="upload successful"></p>
<p><img src="/2018/08/24/神经网络-VGG/images/pasted-19.png" alt="upload successful"></p>
<p>VGG的特点：</p>
<p>小卷积核。作者将卷积核全部替换为3x3（极少用了1x1）；</p>
<p>小池化核。相比AlexNet的3x3的池化核，VGG全部为2x2的池化核；</p>
<p>层数更深特征图更宽。基于前两点外，由于卷积核专注于扩大通道数、池化专注于缩小宽和高，使得模型架构上更深更宽的同时，计算量的增加放缓；</p>
<p>全连接转卷积。网络测试阶段将训练阶段的三个全连接替换为三个卷积，测试重用训练时的参数，使得测试得到的全卷积网络因为没有全连接的限制，因而可以接收任意宽或高为的输入。</p>
<p>特征图</p>
<p>网络在随层数递增的过程中，通过池化也逐渐忽略局部信息，特征图的宽度高度随着每个池化操作缩小50%，5个池化l操作使得宽或者高度变化过程为：224-&gt;112-&gt;56-&gt;28-&gt;14-&gt;7，但是深度depth（或说是channel数），随着5组卷积在每次增大一倍：3-&gt;64-&gt;128-&gt;256-&gt;512-&gt;512。特征信息从一开始输入的224x224x3被变换到7x7x512，从原本较为local的信息逐渐分摊到不同channel上，随着每次的conv和pool操作打散到channel层级上。</p>
<p>特征图的宽高从512后开始进入全连接层，因为全连接层相比卷积层更考虑全局信息，将原本有局部信息的特征图（既有width，height还有channel）全部映射到4096维度。也就是说全连接层前是7x7x512维度的特征图，估算大概是25000，这个全连接过程要将25000映射到4096，大概是5000，换句话说全连接要将信息压缩到原来的五分之一。VGGNet有三个全连接，我的理解是作者认为这个映射过程的学习要慢点来，太快不易于捕捉特征映射来去之间的细微变化，让backprop学的更慢更细一些（更逐渐）。</p>
<p>换句话说，维度在最后一个卷积后达到7x7x512，即大概25000，紧接着压缩到4096维，可能是作者认为这个过程太急，又接一个fc4096作为缓冲，同时两个fc4096后的relu又接dropout0.5去过渡这个过程，因为最后即将给1k-way softmax，所以又接了一个fc1000去降低softmax的学习压力。</p>
<p>feature map维度的整体变化过程是：先将local信息压缩，并分摊到channel层级，然后无视channel和local，通过fc这个变换再进一步压缩为稠密的feature map，这样对于分类器而言有好处也有坏处，好处是将local信息隐藏于/压缩到feature map中，坏处是信息压缩都是有损失的，相当于local信息被破坏了（分类器没有考虑到，其实对于图像任务而言，单张feature map上的local信息还是有用的）。</p>
<p>但其实不难发现，卷积只增加feature map的通道数，而池化只减少feature map的宽高。如今也有不少做法用大stride卷积去替代池化，未来可能没有池化。</p>
<p>卷积组</p>
<p>说到特征图的变化，我们可以进一步切分网络观察整体结构，再次拿出CS231n的博客里的描述网络结构的layer pattern：INPUT -&gt; [[CONV -&gt; RELU]<em>N -&gt; POOL?]</em>M -&gt; [FC -&gt; RELU]*K -&gt; FC，以pooling操作为切分点对整个网络分组的话，我们会得到五组卷积，五组卷积中有2种卷积组的形式，切分后的VGG网络可以描述成下面这样：</p>
<p>前两组卷积形式一样，每组都是：conv-relu-conv-relu-pool；</p>
<p>中间三组卷积形式一样，每组都是：conv-relu-conv-relu-conv-relu-pool；</p>
<p>最后三个组全连接fc层，前两组fc，每组都是：fc-relu-dropout；最后一个fc仅有fc。</p>
<p>虽然CS231n里将这种形式称为layer pattern，但我更喜欢把以卷积起始池化为止的最短结构称之为“卷积组”。</p>
<p>不难发现VGG有两种卷积组，第二种（[conv-relu]-[conv-relu]-[conv-relu]-pool）比第一种（[conv-relu]-[conv-relu]-pool） 多了一个[conv-relu]。我的理解是：</p>
<p>多出的relu对网络中层进一步压榨提炼特征。结合一开始单张feature map的local信息更多一些，还没来得及把信息分摊到channel级别上，那么往后就慢慢以增大conv filter的形式递增地扩大channel数，等到了网络的中层，channel数升得差不多了（信息分摊到channel上得差不多了），那么还想抽local的信息，就通过再加一个[conv-relu]的形式去压榨提炼特征。有点类似传统特征工程中，已有的特征在固定的模型下没有性能提升了，那就用更多的非线性变换对已有的特征去做变换，产生更多的特征的意味；</p>
<p>多出的conv对网络中层进一步进行学习指导和控制不要将特征信息漂移到channel级别上。</p>
<p>上一点更多的是relu的带来的理解，那么多出的[conv-relu]中conv的意味就是模型更强的对数据分布学习过程的约束力/控制力，做到信息backprop可以回传回来的学习指导。本身多了relu特征变换就加剧（权力释放），那么再用一个conv去控制（权力回收），也在指导网络中层的收敛；</p>
<p>其实conv本身关注单张feature map上的局部信息，也是在尝试去尽量平衡已经失衡的channel级别（depth）和local级别（width、height）之间的天平。这个conv控制着特征的信息量不要过于向着channel级别偏移。</p>
<p>输入层</p>
<p>大都是2的N次方，这和网络中卷积或者池化层出现的stride为2的次数有关，比方VGGNet中每个pattern的卷积不会对feature map的宽度和高度有改变，而每个pattern结束前总会做一个stride为2的下采样，因为有5组，那么做5次就是32，所以VGGNet网络input大小一般都是32的倍数，即，n是下采样的次数，a是最终卷积和池化得到的feature map大小，如224或者384。</p>
<p>卷积层</p>
<p>现在常用的是小卷积核如3x3或者1x1。卷积为了保留feature map不变，通常会采取pad为1的操作，其实具体来说应该是：为了保证卷积后的feature map的宽度和高度不变，那么有pad=(F-1)/2，但我觉得这个有点问题，可以改成更一般的形式，不过首先可以看看计算下一层feature map宽高的公式：</p>
<p>因为要保证和一样，有，那么可以导出：</p>
<p>当Stride=1时，那么pad=(F-1)/2。因为现在stride=1的3x3卷积用的多，所以大家会默认说是pad=1（关于这点上，也是由于实验发现这样保留feature map的宽高情况下，性能好的缘故，我认为填补主要是针对stride大于1的情况带来的边界问题，如果input尺寸不是事先设定的，那么就会有边界无法卷积到的问题带来信息丢失。不过这种填补我认为也有一定问题，就是说原本conv3x3去计算对应位置的3x3，而填补后为0，这样相当于少算了一些值，这肯定还是有影响的）。但若stride不是1，那么要保证前后feature map的宽高一样，就要根据上面的公式计算得出。</p>
<p>另一个点是通常与Input比较接近的conv会采用大卷积核。关于接近input层使用较大的卷积核这点，我认为先是考虑到后面的操作，先尽可能用大的卷积核cover更多的原始信息（虽然经过了卷积有一些变换），第二点在于大卷积核带来的大感受野，后面的卷积层能的一个神经元能看到更大的input，第三点是GPU的显存受限，经典的例子就是AlexNet使用stride=4的conv11x11，目的就是从一开始就减少显存占用，其实这里的大stride，我觉得起到了一些正则的作用。但缺点也很明显，因为卷积核变大，矩阵乘法实现卷积时，若没有大stride，那么第一个矩阵的列数，也就是第二个矩阵的行数，会变大，带来大的计算量。所以在AlexNet中，大卷积核也对应使用了大的stride值。</p>
<p>池化层</p>
<p>常见2x2的max-pooling，少见3x3或者更大的kernel。更大的kernel带来的问题是信息丢失带来的信息损失，此外，stride通常为2；<br>在当时也有average pooling，但是在图像任务上max-pooling的效果更胜一筹，所以图像大多使用max-pooling。在这里我认为max-pooling更容易捕捉图像上的变化，梯度的变化，带来更大的局部信息差异性，更好地描述边缘、纹理等构成语义的细节信息，这点尤其体现在网络可视化上。</p>
<p>其实按照以上的设定看来，也是有好处的。卷积专注于保留空间信息前提下的channel变换，而池化则专注于空间信息的变换（下采样）。</p>
<p>全连接转卷积</p>
<p>VGG比较神奇的一个特点就是“全连接转卷积”, 也就是说，作者在测试阶段把网络中原本的三个全连接层依次变为1个conv7x7，2个conv1x1，也就是三个卷积层。改变之后，整个网络由于没有了全连接层，网络中间的feature map不会固定，所以网络对任意大小的输入都可以处理.</p>
<p><img src="/2018/08/24/神经网络-VGG/images/pasted-15.png" alt="upload successful"></p>
<p>上图是VGG网络最后三层的替换过程，上半部分是训练阶段，此时最后三层都是全连接层（输出分别是4096、4096、1000），下半部分是测试阶段（输出分别是1x1x4096、1x1x4096、1x1x1000），最后三层都是卷积层。下面我们来看一下详细的转换过程（以下过程都没有考虑bias，略了）：</p>
<p>先看训练阶段，有4096个输出的全连接层FC6的输入是一个7x7x512的feature map，因为全连接层的缘故，不需要考虑局部性， 可以把7x7x512看成一个整体，25508（=7x7x512）个输入的每个元素都会与输出的每个元素（或者说是神经元）产生连接，所以每个输入都会有4096个系数对应4096个输出，所以网络的参数（也就是两层之间连线的个数，也就是每个输入元素的系数个数）规模就是7x7x512x4096。对于FC7，输入是4096个，输出是4096个，因为每个输入都会和输出相连，即每个输出都有4096条连线（系数），那么4096个输入总共有4096x4096条连线（系数），最后一个FC8计算方式一样，略。</p>
<p>再看测试阶段，由于换成了卷积，第一个卷积后要得到4096（或者说是1x1x4096）的输出，那么就要对输入的7x7x512的feature map的宽高（即width、height维度）进行降维，同时对深度（即Channel/depth维度）进行升维。要把7x7降维到1x1，那么干脆直接一点，就用7x7的卷积核就行，另外深度层级的升维，因为7x7的卷积把宽高降到1x1，那么刚好就升高到4096就好了，最后得到了1x1x4096的feature map。这其中卷积的参数量上，把7x7x512看做一组卷积参数，因为该层的输出是4096，那么相当于要有4096组这样7x7x512的卷积参数，那么总共的卷积参数量就是：</p>
<p>[7x7x512]x4096，这里将7x7x512用中括号括起来，目的是把这看成是一组，就不会懵。</p>
<p>第二个卷积依旧得到1x1x4096的输出，因为输入也是1x1x4096，三个维度（宽、高、深）都没变化，可以很快计算出这层的卷积的卷积核大小也是1x1，而且，通道数也是4096，因为对于输入来说，1x1x4096是一组卷积参数，即一个完整的filter，那么考虑所有4096个输出的情况下，卷积参数的规模就是[1x1x4096]x4096。第三个卷积的计算一样，略。</p>
<p>其实VGG的作者把训练阶段的全连接替换为卷积是参考了OverFeat的工作，如下图是OverFeat将全连接换成卷积后，带来可以处理任意分辨率（在整张图）上计算卷积，而无需对原图resize的优势。</p>
<p><img src="/2018/08/24/神经网络-VGG/images/pasted-16.png" alt="upload successful"></p>
<p>不过可以看到，训练阶段用的是crop或者resize到14x14的输入图像，而测试阶段可以接收任意维度，如果使用未经crop的原图作为输入（假设原图比crop或者resize到训练尺度的图像要大），这会带来一个问题：feature map变大了。比方VGG训练阶段用224x224x3的图作为模型输入，经过5组卷积和池化，最后到7x7x512维度，最后经过无论是三个卷积或者三个全连接，维度都会到1x1x4096-&gt;1x1x4096-&gt;1x1x1000，而使用384x384x3的图做模型输入，到五组卷积和池化做完（即），那么feature map变为12x12x512，经过三个由全连接变的三个卷积，即feature map经历了6x6x4096-&gt;6x6x4096-&gt;6x6x1000的变化过程后，再把这个6x6x1000的feature map进行average，最终交给SoftMax的是1x1x1000的feature map进行分类。</p>
<p>以上便是将全连接转换成卷积以及将转换后的全卷积网络应用到测试阶段的方式。其实进一步来看卷积与全连接，二者最明显的差异不外乎一个前者是局部连接，但其实二者都有用到全局信息，只是卷积是通过层层堆叠来利用的，而全连接就不用说了，全连接的方式直接将上一层的特征图全部用上，稀疏性比较大，而卷积从网络深度这一角度，基于输入到当前层这一过程逐级逐层榨取的方式利用全局信息</p>
<p>1x1卷积</p>
<p>VGG在最后的三个阶段都用到了1x1卷积核，选用1x1卷积核的最直接原因是在维度上继承全连接，然而作者首先认为1x1卷积可以增加决策函数（decision function，这里的决策函数我认为就是softmax）的非线性能力，非线性是由激活函数ReLU决定的，本身1x1卷积则是线性映射，即将输入的feature map映射到同样维度的feature map。</p>
<p>1x1卷积的特点：</p>
<p>专注于跨通道的特征组合：conv1x1根本不考虑单通道上像素的局部信息（不考虑局部信息），专注于那一个卷积核内部通道的信息整合。conv3x3既考虑跨通道，也考虑局部信息整合；</p>
<p>对feature map的channel级别降维或升维：例如224x224x100的图像（或feature map）经过20个conv1x1的卷积核，得到224x224x20的feature map。尤其当卷积核（即filter）数量达到上百个时，3x3或5x5卷积的计算会非常耗时，所以1x1卷积在3x3或5x5卷积计算前先降低feature map的维度。</p>
<p><img src="/2018/08/24/神经网络-VGG/images/pasted-18.png" alt="upload successful"></p>
<p>实验结论</p>
<p>因为作者自己在下面实验的缘故，当然没有测试集的ground truth类别，所以作者就用验证集当做测试集来观察模型性能。这里作者使用两种方式来评估模型在测试集（实际的验证集）的性能表现：single scale evaluation和multi-scale evaluation。实验结论：</p>
<p>LRN层无性能增益（A和A-LRN）。作者通过网络A和A-LRN发现AlexNet曾经用到的LRN层（local response normalization，LRN是一种跨通道去normalize像素值的方法）没有性能提升，因此在后面的4组网络中均没再出现LRN层。 当然我也感觉没啥用，想到max-pooling比average-pooling效果好，我就感觉这个LRN没啥用，不过如果把LRN改成跨通道的max-normal，我感觉说不定会有性能提升。特征得到retain更明显。</p>
<p>深度增加，分类性能提高（A、B、C、D、E）。从11层的A到19层的E，网络深度增加对top1和top5的error下降很明显，所以作者得出这个结论，但其实除了深度外，其他几个网络宽度等因素也在变化，depth matters的结论不够convincing。</p>
<p>conv1x1的非线性变化有作用（C和D）。C和D网络层数相同，但D将C的3个conv3x3换成了conv1x1，性能提升。这点我理解是，跨通道的信息交换/融合，可以产生丰富的特征易于分类器学习。conv1x1相比conv3x3不会去学习local的局部像素信息，专注于跨通道的信息交换/融合，同时为后面全连接层（全连接层相当于global卷积）做准备，使之学习过程更自然。</p>
<p>多小卷积核比单大卷积核性能好（B）。作者做了实验用B和自己一个不在实验组里的较浅网络比较，较浅网络用conv5x5来代替B的两个conv3x3。多个小卷积核比单大卷积核效果好，换句话说当考虑卷积核大小时：depths matters。</p>
<p>引用：<br><a href="https://blog.csdn.net/jyy555555/article/details/80515562" target="_blank" rel="noopener">https://blog.csdn.net/jyy555555/article/details/80515562</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Isaac-Li.github.io/2018/08/21/神经网络-AlexNet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Isaac Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Isaac Li">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/神经网络-AlexNet/" itemprop="url">神经网络-AlexNet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T17:09:00+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Deep Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一。AlexNet 网络结构</p>
<p><img src="/2018/08/21/神经网络-AlexNet/images/pasted-14.png" alt="upload successful"><br>第一个模块 conv_1：</p>
<p>输入的图片大小为224x224x3</p>
<p>有96个卷积核,尺寸为11x11,即11x11x96。步长（stride）为4.</p>
<p>第二个模块 conv_2:</p>
<p>输入的tensor为27x27x96</p>
<p>卷积核的大小为: 5x5x256,步长为1,因此，步长为1时，feature map为27x27x256.</p>
<p>同样紧跟ReLU,和LRN层.尺寸不变</p>
<p>最大池化层,核大小为3x3,步长为2</p>
<p>第三个模块 conv_3:</p>
<p>输入tensor为13x13x256</p>
<p>卷积核 3x3x384,步长为1,feature map为:13x13x384</p>
<p>加上ReLU，尺寸不变</p>
<p>无最大池化层</p>
<p>第四个模块 conv_4:</p>
<p>配置和conv_3一样，因此feature map为:13x13x384</p>
<p>第五个模块 conv_5:</p>
<p>输入tensor为13x13x384</p>
<p>卷积核 3x3x256,步长为1,feature map为:13x13x256<br>加上ReLU，尺寸不变<br>最大池化层，核大小3x3, 步长为2, 因此feature map:6x6x256</p>
<p>第六个模块 fc_1:</p>
<p>卷积核6x6x256x4096，输出为一维向量，4096个元素。<br>加上ReLU，尺寸不变</p>
<p>第七个模块 fc_2:</p>
<p>输出为一维向量，4096个元素。<br>加上ReLU，尺寸不变</p>
<p>第8个模块 fc_3:</p>
<p>输出为一维向量，1000个元素。最后一层用了softmax，输出为1000个种类的各类概率值.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Isaac-Li.github.io/2018/08/20/神经网络-Lenet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Isaac Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Isaac Li">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/神经网络-Lenet/" itemprop="url">神经网络-LeNet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T15:44:00+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Deep-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Deep Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>LeNet-5 的结构</p>
<p><img src="/2018/08/20/神经网络-Lenet/images/pasted-10.png" alt="upload successful"></p>
<p>一。输入层：   输入的图像大小是 32x32pixel的图像，其中而数据库中是20x20的信息在28x28pixel的中心。拓展图像是为了高层特征可以位于高层感受野中心。例如图中A的上方的拐点，如果没有拓展图像输入，则其对应在S2中的位置很有可能位于feature map的最上方，无法处于任何感受野的中心。 </p>
<p>二。隐藏层</p>
<ol>
<li><p>C1 卷积层：kernel size=5x5，步长为1，无填充，生成6个feature map<br>参数个数为(5x5+1)x6=156(其中5x5对应kernel size，+1为bias，6为feature map 数目）。<br>连接数为156x28x28=122304(156为参数个数，其中feature map上每个像素点对应156个链接）。</p>
</li>
<li><p>S2 下采样层（Pooling）： kernel size=2x2，步长为2，无填充。</p>
<p>   下采样的作用： 利用图像的局部相关性原理，对图像进行子抽样，可以减少数据处理量，同时又保留有用的信息。</p>
<p>   参数个数为 6x(1+1)=12。（因为LeNet-5采用的sigmoid(a*average(x)+b)作为池化函数）</p>
<p>   链接个数为6x14x14x(2x2+1)=5880。六个feature map，总共6x14x14个feature，每个feature由4个C2特征+1个bias。</p>
</li>
<li><p>C3 卷积层：kernel size=5x5，步长为1，无填充，生成16个feature map。</p>
</li>
</ol>
<p>C3中的每一个Feature Map连接到S2的所有6个Feature Map或者是几个Feature Map。表示本层的Feature Map是上一层提取的Feature Map的不同组合。为什么不把S2的每一个Feature Map连接到C3的每一个Feature Map中？原因有2： 第一，不完全连接机制连接的数量保持在合理范围，第二，这样破坏了网络的对称性，由于不同的Feature Map有不同的输入，所以迫使他们抽取不同的特征（理想状态特征互补）。</p>
<p>C3与S2的连接关系<br><img src="/2018/08/20/神经网络-Lenet/images/pasted-11.png" alt="upload successful"></p>
<p>   C3的前6个Feature Map以S2中的3个相邻的Feature Map子集为输入，接下来的6个Feature Map以S2中相邻的4个Feature Map作为输入，接下来的3个以不相邻的4个Feature Map子集作为输入，最后一个将S2中所有的Feature Map作为输入的话，C3将会有1516个可训练参数和151600个连接。</p>
<p>   参数个数为(5x5x3+1)x6+(5x5x4+1)x9+(5x5x6+1)=1516个。括号内部为kernel_size x kernel_size x feature_map_num + bias_num，表示从feature_map_size卷积得到的feature map所需要的参数个数；括号外为相应得到feature map的数目</p>
<p>4.S4下采样层 （Pooling）：，kernel size=2x2，步长为2，无填充。</p>
<p>参数个数为16x2=32</p>
<p>链接个数为5x5x16x(2x2+1)=2000。(5为新生成feature map的size，16为feature map的数目，2为kernel size，1为bias。</p>
<ol start="5">
<li><p>C5 卷积层: kernel size=5x5，步长为1，无填充，全连接生成120个feature map。</p>
<p>参数个数为120x(5x5x16+1)=48120</p>
<p>链接个数等于参数个数，因为新生成feature map的size为1。</p>
<p>6.F6 全连接层:输入120个，输出84个</p>
<p>链接个数=参数个数=(120+1)x84，其中+1为bias。</p>
<p>全连接层的激活函数为Atanh(Sx)，其中A和S为超参数。</p>
<p>输出表述是将给定的label转换为一个向量，作为神经网络的真值。</p>
<p>文章中是把图片对应的字符在7x12的bitmap上画出，白值为-1，黑值为1，其中84个像素平铺之后的向量对应为相应字符的表述，作为真值与F6连接。这样做的优点有：</p>
</li>
</ol>
<ol>
<li>对于识别全打印的ASCII字符有用（单独数字无用） </li>
<li>外表相近的字符如”i”和”1”等在这种表述中也相近，这样在神经网络之后加入个依靠语义更正的系统，可以提高准确率。 </li>
<li>1 of N的表述在N大于几十的时候就会表现不好。 </li>
<li><p>这样的表示可以用于拒绝非字符，而不是所有的都识别为字符。<br>设置“白值为-1，黑值为1”的原因是为了把函数限定在sigmoid函数斜率较大的区域，否则收敛较慢</p>
<p>三。输出层</p>
<p>全连接层，共有10个节点，分别代表数字0到9，且如果节点i的值为0，则网络识别的结果是数字i。采用的是径向基函数（RBF）的网络连接方式。</p>
<p>LeNet-5识别数字3的过程<br><img src="/2018/08/20/神经网络-Lenet/images/pasted-12.png" alt="upload successful"></p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://Isaac-Li.github.io/2018/08/15/Java-虚拟机/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Isaac Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Isaac Li">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/Java-虚拟机/" itemprop="url">Java 虚拟机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-15T17:04:00+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>深入拆解Java虚拟机-极客时间 笔记</p>
<p>01 Java 代码是怎么运行的:</p>
<p>从虚拟机视角看，执行Java代码首先要将它编译而成的class文件加载到Java虚拟机中。加载后的Java类会被存放于方法区中。实际运行时，虚拟机会执行方法区的代码。</p>
<p>Java虚拟机会在内存中划分出堆和栈来存储运行时数据。会将栈细分为面向Java方法的Java方法栈，面向本地方法的本地方法栈，以及存放各个线程执行位置的PC寄存器。每当调用进入一个Java方法，Java虚拟机会在当前线程的Java方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。当退出当前执行的方法时，不管是正常返回还是异常返回，Java虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。</p>
<p>为了满足不同用户场景需要，HotSpot内置了多个即时编译器：C1 C2 Graal。C1又叫Client编译器，面向的是对启动性能有要求的客户端GUI程序。采用的优化手段相对简单，因此编译时间较短。C2 又叫Server编译器，面向的是对峰值性能有要求的服务器端程序。从Java7开始，HotSpot默认采用分层编译的方式：热点方法首先会被C1编译，而后热点方法中的热点会进一步被C2编译。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Isaac Li" />
            
              <p class="site-author-name" itemprop="name">Isaac Li</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Isaac-Li" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:lee_isaac@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Isaac Li</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
